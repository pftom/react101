name: React 入门教程
description: >-
  本篇教程通过构建一个井字棋游戏来讲解 React 的基础知识，是非常经典的 Learn by doing
  的教授/学习技术的方式。通过学习本篇教程你不仅可以学习到如何使用脚手架初始化项目，学习 React 的基础知识如
  props，state，组件等，还可以学习一些编写代码的最佳实践，最后完成一个带有 “时间旅行”
  的井字棋游戏。相信你在学习完本篇教程之后，会成为这场游戏里面的最大胜者！
topics:
  - React
categories:
  - 前端
  - React
  - 入门
id: 5c8fdb60a9cbfbc27aae247a4a4b7376
created: '2019-11-13T03:11:19.855Z'
github: 'https://github.com/pftom/react101'
updated: 2019-11-19T11:11:28.977Z
splits:
  - name: 用 React 实现一个井字棋游戏（一)
    description: >-
      本篇教程通过构建一个井字棋游戏来讲解 React 的基础知识，是非常经典的 Learn by doing
      的教授/学习技术的方式。通过学习本篇教程你不仅可以学习到如何使用脚手架初始化项目，学习 React 的基础知识如
      props，state，组件等，还可以学习一些编写代码的最佳实践，最后完成一个带有 “时间旅行”
      的井字棋游戏。相信你在学习完本篇教程之后，会成为这场游戏里面的最大胜者！
    start: fd83d85
    end: 08c001e
  - name: 用 React 实现一个井字棋游戏（二）
    description: >-
      这是 React 入门教程的第二部分，主要介绍了组件、不可变性、列表和 Key 等知识，通过再次进行组件状态提升 来强调其在 React
      哲学中的重要地位。这一部分与上一部分很好的串联在一起，相比上一部分内容会更有难度一点。
    start: b72c6b1
    end: 4493d81
steps:
  - name: 代码准备
    commit: fd83d85
    diff:
      - file: .gitignore
      - file: README.md
        display: false
      - file: package.json
        display: false
      - file: public/favicon.ico
        display: false
      - file: public/index.html
        display: false
      - file: public/logo192.png
        display: false
      - file: public/logo512.png
        display: false
      - file: public/manifest.json
        display: false
      - file: public/robots.txt
        display: false
      - file: src/index.css
        display: true
        explain:
          pre: 4.在 `src/` 文件夹下创建一个名为 `index.css` 的文件，然后在里面加入下面的 CSS 代码并保存。
      - file: src/index.js
        display: true
        explain:
          pre: 5.在 `src/` 文件夹下创建一个名为 `index.js` 的文件，然后在里面加入如下的 JS 代码并保存。
          post: >-
            6.在 `src/` 文件下的 `index.js`  文件内容的顶部加上下面三行代码：


            ```JavaScript

            import React from 'react';

            import ReactDOM from 'react-dom';

            import './index.css';

            ```


            现在，如果你在项目文件夹下面运行 `npm start` 然后再在浏览器中打开 `http://localhost:3000`
            ，你应该能看到一个空的 “井字棋” 游戏区域。


            我们推荐你根据[这些指导](https://www.babeljs.cn/docs/editors)来配置你编辑器的语法高亮。
      - file: yarn.lock
        display: false
    explain:
      pre: >-
        我们将在这篇教程中学习制作一个小游戏。你可能不想看这个教程，因为你不是做游戏的 -- 但是试着给它一个机会。在这篇教程中你学到的技术是构建一个
        React 应用的基础，熟练掌握这些技术会让你更加深入的理解 React。


        这篇教程被分为如下几个部分：


        - [代码准备](#代码准备) 将会给你学习这篇教程需要的初始代码框架。

        - [通过 Prop 传递数据](#通过-props-传递数据)、[编写交互式组件](#编写交互式组件) 将会教给你 React
        的基础：components，props，state。

        - [状态提升](#状态提升)、[使用函数式组件](#使用函数式组件)、[开始翻转](#开始翻转)、[显示获胜者](#显示获胜者)会教给你在
        React 开发将用到的绝大部分技术。

        - [再次状态提升](#再次状态提升)，[展示移动历史](#展示移动历史)、[加上
        key](#加上-key)、[实现时间旅行](#实现时间旅行) 将会带你深入了解 React 的独特长项。


        你不需要一口气学完整篇教程，但是只要你学习了其中的 1-2 个部分就可以收获很多价值，所以如果有时间和精力，你应该尝试着多学几个部分。


        ### 我们将要做什么


        在这篇教程中，我们将为你展示用 React 构建一个交互式的 “井字棋”  游戏。


        你可以在这里看到我们的构建成果：[最终结果](https://codepen.io/pftom/pen/xxxaJam?editors=0010)。如果你现在对代码还不是很理解，如果说你还不熟悉代码语法，别担心！这篇教程的目的就是帮助你理解
        React 和它的语法。


        我们推荐你在继续阅读教程之前先检查一下这个 “井字棋”
        游戏是怎么运作的。你能看到的其中一个特点就是在游戏棋盘右边有一个有序列表。这个列表向你展示了发生在这个游戏上的移动历史，随着游戏继续，这个历史列表也会变动。


        当你对这个 “井字棋”
        游戏的运作有一定了解了之后，你就可以关闭它了。在这篇教程中，我们将会以一个简单的代码模板开始。我们的下一步是教会你构建这个游戏。


        ### 前提条件


        我们假定你对 HTML 和 JavaScript 有一定了解，但即使你是从其他语言转过来的，你也可以跟着学习。我们也假定你对编程概念如
        functions，objects，arrays 有一定了解，最好还知道一点关于 classes 的知识。


        如果你想回顾一下 JavaScript
        的知识，我们推荐你阅读[这篇指南](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript)。请注意，我们会使用一些
        ES6 的语法 -- JavaScript 最近的一个版本。在这篇教程，我们会使用 [arrow
        functions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，[classes](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)，[let](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let)，和
        [const](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const)。你可以使用
        [Babel
        REPL](https://www.babeljs.cn/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=7.7.3)
        来检查 ES6 代码编译之后的结果。


        ### 开发环境准备


        1.确保在你的机器上安装了 [Node.js](https://nodejs.org/en/) 。


        2.使用 Create React App 来创建一个新项目。


        ```Bash

        npx create-react-app my-app

        cd my-app

        npm start

        ```


        > **注意**

        > 第一行的 `npx` 不是拼写错误 -- 它是 [npm 5.2+ 附带的 package
        运行工具](http://www.ruanyifeng.com/blog/2019/02/npx.html)。


        [Create React App](https://github.com/facebook/create-react-app) 是一个学习
        React 的舒适环境，而且是使用 React 构建一个新的单页应用的最佳方式。


        Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build
        pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 [Babel](https://www.babeljs.cn/) 和
        [Webpack](https://webpack.docschina.org/)，但你无需了解它们的任何细节。


        当你准备好部署到生产环境时，执行 `npm run build` 会在 build 文件夹内生成你应用的优化版本。你能从它的
        [README](https://github.com/facebook/create-react-app#create-react-app--)
        和用户指南了解 [Create React App](https://create-react-app.dev/) 的更多信息。


        > 单页面应用(single-page application)，是一个应用程序，它可以加载单个 HTML
        页面，以及运行应用程序所需的所有必要资源（例如 JavaScript 和
        CSS）。与页面或后续页面的任何交互，都不再需要再访问服务器加载资源，即页面不会重新加载。

        >

        >你可以使用 React 来构建单页应用程序，但不是必须如此。React 还可用于增强现有网站的小部分，使其增加额外交互。用 React
        编写的代码，可以与服务器端渲染的标记（例如 PHP）或其他客户端库同时使用。实际上，这也正是 Facebook 内部使用 React 的方式。


        3.删除刚刚创建的 `my-app` 项目 `src/` 目录下的所有文件。


        > **注意：**

        > **不要删除整个 `src` 文件夹，只需要删除它里面的所有源文件。**我们将在接下来的步骤中在 `src`
        中创建我们所需要构建的游戏初始模板代码文件。


        ```Bash

        cd my-app

        cd src


        # 如果你在使用 Mac 或者 Linux：

        rm -f *


        # 或者，你在使用 Windows：

        del *


        # 然后，切回到项目目录文件夹下

        cd ..

        ```
      post: >-
        ### 帮帮忙，我遇到了问题！


        如果你遇到了问题，可以访问我们的[社区支持](https://tuture.co/about/)网站。[Gitter](https://gitter.im/tuture-dev/tuture)
        是一个很棒的反馈平台，你可以较快的在这上面得到帮助。如果你的问题一直没有得到解答，请给我们提交
        [Issue](https://github.com/tuture-dev/hub)，我们将会帮助你解决。
  - name: 通过 Props 传递数据
    commit: 3cf4f5f
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: >-
            让我们来尝试修改一些代码，从 Board 组件向 Square 组件传递一些数据。


            我们强烈推荐你在学习这篇教程的时候跟着动手敲一遍代码，而不是简单的复制/粘贴。这会帮助你形成肌肉记忆并且会有更深层次的理解。


            修改 Board 的 `renderSquare` 方法中的代码，传递 `value` 属性给 Square：


            ```JavaScript

            class Board extends React.Component {
              renderSquare(i) {
                return <Square value={i} />;
              }
            }

            ```


            修改 Square 的 `render` 方法来展示传进来的 `value` ，将 `{/* TODO */}` 替换成
            `{this.props.value}`：


            ```JavaScript

            class Square extends React.Component {
              render() {
                return (
                  <button className="square">
                    {this.props.value}
                  </button>
                );
              }
            }

            ```


            当修改完保存之后，如果你的程序运行着，那么你应该能看到如下的变化。


            改之前是这样的：


            ![](tuture-assets/tictac-empty-1566a4f8490d6b4b1ed36cd2c11fe4b6-a9336.png)


            修改之后你将会看到每个 Square 都渲染展示了一个数字：


            ![](tuture-assets/tictac-numbers-685df774da6da48f451356f33f4be8b2-be875.png)


            最终 `src/index.js` 的代码为下面的样子：
          post: >-
            [查看此时的整个项目代码](https://github.com/pftom/react101/tree/3cf4f5f9b1537ae55cbf676cad574d00986b4b24/src)


            恭喜你！你刚刚从父组件 Board 传递了 props 给子组件 Sqaure。在 React 中，父组件通过传递 props
            给子组件来完成数据的流动。
    explain:
      pre: >-
        ### 什么是 React？


        React 是一个用于构建用户界面的声明式的，高效的且灵活的 JavaScript 库。它允许你通过组合一些小且独立的 “组件” 来构建复杂的
        用户界面。


        React 有几种不同的类型的组件，但是他们都继承自 `React.Component` 类：


        ```JavaScript

        class ShoppingList extends React.Component {
          render() {
            return (
              <div className="shopping-list">
                <h1>Shopping List for {this.props.name}</h1>
                <ul>
                  <li>Instagram</li>
                  <li>WhatsApp</li>
                  <li>Oculus</li>
                </ul>
              </div>
            );
          }
        }


        // Example usage: <ShoppingList name="Mark" />

        ```


        我们马上就会了解到上面这些有趣的 类XML 的标签意思。我们使用组件（Components）来告诉 React
        我们想在屏幕上看到什么。当我们的数据改变时，React 将会高效的更新并重新渲染我们的组件。


        在上面的代码中，ShoppingList 是一个 **React 组件类**，或者说是 **React 组件类型**。组件接受 `props`
        作为参数，然后通过 `render` 方法来展示它所返回的视图层级结构。


        `render` 方法返回一个你希望在屏幕上看到内容的描述。React 处理这些描述，并展示其结果。实际上，`render` 返回一个
        **React element** ，这是对将要渲染内容的一个轻量级描述。大多数的 React 开发者使用被称之为 "JSX"
        的特殊语法来编写这些视图层级结构，因为它让编写更简单。`<div />` 语法在编译时被转换为
        `React.createElement('div')`。上面的代码例子和下面是等价的：


        ```JavaScript

        return React.createElement('div', {className: 'shopping-list'},
          React.createElement('h1', /* ... h1 children ... */),
          React.createElement('ul', /* ... ul children ... */)
        );

        ```


        [查看完整的编译代码。](https://www.babeljs.cn/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=DwEwlgbgBAxgNgQwM5IHIILYFMC8AiJACwHsAHUsAOwHMBaOMJAFzwD4AoKL7r4QgRlYBlEuSrUoAGUZMoAM2IAnKAG8mhRgDpSiskk2VMWAL7AA9AI48ewAK5wr1mw1YBJSswTVFmcy85O3MAuAOqECExIAILkfmCOgVDB8QDyMPa2SHEJ1ub2Obxm4BCsQA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=7.7.3)


        如果你对这感到很好奇，`createElement` 在 React 的 [API
        文档](https://zh-hans.reactjs.org/docs/react-api.html#createelement)里面有更加详细的描述。


        JSX 能使用 JavaScript 的全部功能。你能在 JSX 的大括号里面放入任何 JavaScript 表达式。每个 React
        element 也是一个 JavaScript 对象，你可以将它保存在一个变量中，也可以在程序中传递它。


        上面的 `ShoppingList` 组件只渲染了一些内建的 DOM 组件，像 `<div />` 和 `<li />`
        等。但是你也能组合和渲染自定义组件。比如，我们我们现在可以通过 `<ShoppingList />` 来引用整个购物列表。每个 React
        组件都是被封装好的，可以独立的运行；这使得你能使用简单的组件来构建复杂的用户界面。


        ### 了解初始代码


        现在打开项目文件夹里面 `src/index.js` 代码。这份初始代码是我们将要构建的内容骨架。我们已经添加了 CSS
        样式，所以你只需要关注学习 React 以及如何用它编写 “井字棋” 游戏。


        通过查看代码，我们可以注意到这份代码里面有三个组件：


        - Square

        - Board

        - Game


        Square 组件渲染了单一的一个 `<button>` ，Board 组件渲染了 9 个 Square 组件。Game 组件渲染了一个
        Board 和一些被注释的占位值，在后续的讲解中，我们将会修改这些占位值。目前这份代码中还没有交互式的组件。
  - name: 编写交互式组件
    commit: dc9cb48
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 我们修改代码如下：
          post: >-
            让我们来看一看上面的代码做了什么事。


            首先，我们在 Square 类中加入了一个 constructor 来初始化 state。


            > **注意**

            > 在 [JavaScript
            类](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)中，当在子类中定义
            constructor 时，你总是需要调用 `super` 函数。所有有 constructor 的 React
            组件类应该在其中首先调用 `super(props)` 函数。


            然后我们修改了 Square 的 `render` 方法来展示被点击时的当前的 state 值：


            - 在 `<button>` 标签里面使用 `{this.state.value}` 来替换 `{this.props.value}`
            。

            - 使用 `onClick={() => this.setState({value: 'X'})` 来替换
            `onClick={...}` 事件处理函数。


            在 Square 的 `render` 方法中，通过在 `onClick` 处理函数中调用 `this.setState`
            方法，我们告诉 React ，每当 `<button>` 被点击时就重新渲染 Square 组件。在更新之后，Square 的
            `this.state.value` 将会变成 `'X'` ，所以我们能在游戏板上看到 `X`。点击任何 Square，都会出现
            `X`。


            当你在组件中调用 `this.setState` 时，React 将会自动更新这个组件中的所有子组件。


            [查看此时的所有项目代码](https://github.com/pftom/react101/tree/dc9cb48160fb9ec8894ff0f6c74524f4c2722780)


            ### 开发工具


            [Chrome](https://github-production-release-asset-2e65be.s3.amazonaws.com/221361523/7e14ee00-0961-11ea-8eeb-8b3fab0c9ac0?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20191117%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20191117T094150Z&X-Amz-Expires=300&X-Amz-Signature=8b9e5dbd0063fa57281f85a54802e45ccb8176607042d5ae06bb55d322bddecf&X-Amz-SignedHeaders=host&actor_id=26423749&response-content-disposition=attachment%3B%20filename%3D4.2.0_0.zip&response-content-type=application%2Foctet-stream)
            和
            [Firefox](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)
            的 React Devtools 扩展插件能让你在开发者工具中查看 React 组件树。


            ![](tuture-assets/devtools-878d91461c78d8f238e116477dfe0b46-6ca3b.png)


            React DevTools 能让你查看 React 组件的 props 和 state。


            当安装完 React DevTools 之后，你使用鼠标右键点击页面上的任意元素，然后在弹出的菜单栏中选择 “检查”
            来打开开发者工具，然后你会看到在开发者工具的标签栏最右边会出现 React 标签（“⚛️ Components” and “⚛️
            Profiler”）
    explain:
      pre: >+
        让我们在点击 Square 组件时给它填充 "X"。首先，将 Square 组件中的 `render()` 函数的中返回的 button
        标签修改成下面这样：


        ```JavaScript

        class Square extends React.Component {
          render() {
            return (
              <button className="square" onClick={function() { alert('click'); }}>
                {this.props.value}
              </button>
            );
          }
        }

        ```


        如果你现在点击 Square，你应该能在浏览器中看到弹出框。


        > **注意**

        > 为了减少打字量和避免 [this
        的混淆行为](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)，在下面和之后的代码中我们将使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)作为事件处理函数：


        ```JavaScript
         class Square extends React.Component {
          render() {
            return (
             <button className="square" onClick={() => alert('click')}>
                {this.props.value}
              </button>
            );
          }
        }

        ```

        > 注意到我们使用了 `onClick={() => alert('click')}`，我们给 `onClick` 属性传递了一个函数。只有到
        button 被点击时，React 才会调用这个函数。忘记 `() =>` 而只写了
        `onClick={alert('click')}`是一个很容易犯的错误，这会导致每次组件重新渲染时都会调用 alert 函数。


        在下一步中，我们希望 Square 能 ”记住“ 自己被点击了，同时能填充一个 “X" 标记。为了 “记住” 事情，组件需要
        **state**。


        React 组件通过在 `constructor` 里面设置 `this.state` 的来获得 state。当在组件中定义
        `this.state` 时，它应该被认为是这个组件的私有属性。让我们在 `this.state` 中保存 Square 的当前值，然后在
        Square 被点击时修改它。

  - name: 状态提升
    commit: 08c001e
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: >-
            在 Board 中添加 constructor，然后设置初始 state 包含一个有 9 个 null 值的数组，对应着 9 个
            Square。


            ```JavaScript

            class Board extends React.Component {
               constructor(props) {
                 super(props);
                 this.state = {
                   squares: Array(9).fill(null),
                 };
               }

              renderSquare(i) {
                return <Square value={i} />;
              }
            ```


            当我们之后填充游戏板时，`this.state.squares` 数组看起来会像下面这样：


            ```JavaScript

            [
              'O', null, 'X',
              'X', 'X', 'O',
              'O', null, null,
            ]

            ```

            Board 的 `renderSquare` 方法目前看起来是这样的：


            ```JavaScript
             renderSquare(i) {
                return <Square value={i} />;
              }
            ```


            一开始，我们从 Board [向下传递 props ](#通过-props-传递数据)值给 Square 来展示从 0-9
            的数字。之后，我们通过 [Square 的自带 state](#编写交互式组件) 将数字设置成 “X”。这就是为什么 Square
            目前忽略了通过 Board 传下来的 `value` 值。


            现在，我们将再次使用传递 props 的机制。我们通过修改 Board 组件来指导每个 Square 当前的值（`'X', `'O'`,
            或者 `null`）。我们已经在 Board 的 constructor 中定义了 `squares`  数组，现在我们将修改
            Board 的 `renderSquare` 方法来读取它。


            ```JavaScript
             renderSquare(i) {
                return <Square value={this.state.squares[i]} />;
              }
            ```


            现在每个 Square 将会接收 `value` props，它的值可能是 `'X'`，`'O'` 或者 `null`。


            接下来，当 Square 被点击时，我们需要作出相应的改变。现在 Board 组件维护着 Square 的填充值数组
            squares。我们需要创造一种在 Square 中更新 Board 的 state 值的方式。因为 state
            被认为是它所在定义的组件的私有属性，我们不能直接在 Square 中更新 Board 的 state 值。


            取而代之的是，我们从 Board 给 Square 传递一个函数，当 Square 被点击时，我们调用这个函数。我们修改 Board 的
            `renderSquare` 方法如下：


            ```JavaScript
              renderSquare(i) {
                return (
                  <Square
                    value={this.state.squares[i]}
                    onClick={() => this.handleClick(i)}
                  />
                );
              }
            ```


            > **注意**

            > 为了可读性，我们将返回的代码分割成多行代码，然后在两端加上了圆括号，这样 JavaScript 就不会在 return
            后面加上分号来破坏我们的代码。


            我们现在从 Board 给 Square 传递了两个 props：`value` 和 `onClick` 。`onClick`
            参数是是一个函数，当 Square 被点击时就会调用它。我们将对 Square 做如下的修改：


            - 在 Square 的 `render` 方法中，用 `this.props.value` 来替换
            `this.state.value`。

            - 在 Square 的 `render` 方法中，用 `this.props.onClick()` 来替换
            `this.setState`。

            - 删除 Square 中的 `constructor` ，因为 Square 不再追踪游戏的 state。


            在做出上面的改变修改之后，Square 组件变成了下面这样：


            ```JavaScript

            class Square extends React.Component {
              render() {
                return (
                  <button
                    className="square"
                    onClick={() => this.props.onClick()}
                  >
                    {this.props.value}
                  </button>
                );
              }
            }

            ``` 


            当 Square 被点击时，由 Board 提供的 `onClick` 函数就会调用。下面是对我们上面所做的一个回顾：


            1. 在内建 DOM 元素  `<button>` 组件上的 `onClick` 属性告知 React 要设定一个事件监听器。

            2. 当 button 被点击时，React 将会调用在 Square 的 `render()` 方法里定义的 `onClick`
            事件处理函数。

            3. 事件处理函数会调用 `this.props.onClick()`。Square 的 `onClick` props 是由
            Board 传下来的。

            4. 因为 Board 将 `onClick={() => this.handleClick(i)} 传给 Square，所以当
            Square 被点击时，就会调用 `this.handleClick(i)` 方法。

            5. 我们目前还没有定义 `handleClick(i)` ，所以当点击 Square 之后，我们的程序就崩掉了，你应该可以看到有着像
            “this.handleClick is not a function” 这样的红色的错误提示出现在屏幕上。


            > **注意**

            > `button` DOM 元素的 `onClick` 属性对 React 来说有特殊的意义，因为它是内建的组件。对于自定义组件，像
            Square ，起名字取决于你。我们可以给 Square 的 `onClick` props 和 Board 的
            `handleClick` 方法起任何名字，代码都会如期运行。在 React 中，我们约定使用 `on[Event]` props
            来代表事件，`handle[Event]` 来代表事件处理方法。


            当我们尝试点击 Square 时，程序会崩溃，因为我们目前还没有在 Board 定义 `handleClick` 
            方法，我们将马上加上它：


            ```JavaScript

            class Board extends React.Component {
              constructor(props) {
                super(props);
                this.state = {
                  squares: Array(9).fill(null),
                };
              }

              handleClick(i) {
                const squares = this.state.squares.slice();
                squares[i] = 'X';
                this.setState({squares: squares});
              }

              renderSquare(i) {
                return (
                  <Square
                    value={this.state.squares[i]}
                    onClick={() => this.handleClick(i)}
                  />
                );
              }

              render() {
                const status = 'Next player: X';

                return (
                  <div>
                    <div className="status">{status}</div>
                    <div className="board-row">
                      {this.renderSquare(0)}
                      {this.renderSquare(1)}
                      {this.renderSquare(2)}
                    </div>
                    <div className="board-row">
                      {this.renderSquare(3)}
                      {this.renderSquare(4)}
                      {this.renderSquare(5)}
                    </div>
                    <div className="board-row">
                      {this.renderSquare(6)}
                      {this.renderSquare(7)}
                      {this.renderSquare(8)}
                    </div>
                  </div>
                );
              }
            }

            ```


            最后我们的代码看起来像下面这样：
    explain:
      pre: >-
        我们目前已经有了 “井字棋” 游戏的基础骨架。为了完成这个游戏，我们需要在游戏板上交替出现 “X" 和 “O”，并且我们需要一种方式来决定胜者。


        目前，每个 Square 组件都保留着游戏的 state。为了检查胜者，我们需要在一个地方维护这 9 个 Square 的值。


        我们也许可以想到 Board 可以找每个 Square 要它们的 State。尽管这个方法在 React
        中是可行的，但我们不建议你这么做，因为这会使代码编写难于理解，造成隐含的 BUG，并且让重构变得困难。然而，最好的方法是将游戏的 state
        保存在 Board 组件中而不是每个 Square 组件中。Board 组件能通过传递 props 告诉每个 Square
        该展示什么，[就像我们之前给 Square 传递数字一样](通过-props-传递数据)。


        **为了从多个子组件中收集数据，或者使得两个子组件能相互通信，你需要在它们共有的父组件上面定义共享的 state。父组件能够通过传递 props
        将 state 传回给子组件；这使得子组件之间相互同步并且子组件和父组件也保持同步。**


        将状态提升到父组件在 React 的组件重构中时很常见的方式 -- 让我们抓住这个机会来尝试它。
      post: >
        [查看目前所有的项目代码](https://github.com/pftom/react101/tree/08c001e3dd2fd255ebb842f65a697344cf090c44)


        在经过上面的修改之后，我们现在应该又可以点击 Square 然后填充 “X” 了，就像我们之前的效果一样。然而，现在游戏的 state
        统一保存在 Board 组件中而不是各个 Square 组件中。当 Board 的 state 改变时，Square
        组件将会自动重新渲染。将所有的 Square 的 state 保存在 Board 组件中能让我们在之后判断获胜者。


        因为 Square 组件不再维护 state，它从 Board 组件接收 `value` ，然后在被点击时，通知 Board 修改
        state。用 React 的术语说，Square 组件现在是一个受控组件。Board 组件现在完全控制着它们。


        注意到在 `handleClick` 方法中，我们在数组上调用了 `.slice()` 方法来创建一个 `squares`
        的拷贝而不是直接修改它。我们将在下部分讲解为何我们要创建 `squares` 的拷贝。
  - name: 使用函数式组件
    commit: b72c6b1
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 最终我们的代码变成了这样：
          post: >-
            [查看此时的所有项目代码](https://github.com/pftom/react101/tree/b72c6b192d1de1a243d17e2237982230b83b4176)


            > **注意**

            > 当我们将 Square 修改成函数式组件之后，我们也将 `onClick={() => this.props.onClick()}`
            改成了更短的 `onClick={props.onClick}` （注意到大括号内的前后都没有了圆括号）
    explain:
      pre: >-
        ### 为什么不变性是很重要的


        在之前的代码例子中，我们建议你使用 `.slice()` 方法来创建 `squares`
        的一份拷贝而不是直接修改它。我们将马上讨论不变形以及为什么不变形是值得学习的。


        一般有两种方式修改数据。第一种方法就是通过直接修改数据的值让数据产生突变。第二种方法是在数据的拷贝上做修改然后替代原数据。


        #### 突变式的数据修改：


        ```JavaScript

        var player = {score: 1, name: 'Jeff'};

        player.score = 2;

        // Now player is {score: 2, name: 'Jeff'}

        ```


        #### 非突变式的数据修改：

        ```JavaScript

        var player = {score: 1, name: 'Jeff'};


        var newPlayer = Object.assign({}, player, {score: 2});

        // 现在 player 没有被修改，但是 newPlayer 的值却变成了 {score: 2, name: 'Jeff'}


        // 或者你想使用对象结构语法，你可以这样写：

        // var newPlayer = {...player, score: 2};

        ```


        即使没有突变的修改数据，最终的结果却是一样的，我们马上来说一下这样做的几个好处。


        #### 复杂的功能变简单


        不可变性使得复杂的功能变得很容易实现。在这篇教程的后面，我们将会实现一个 “时间旅行” 功能，它使得我们的 “井字棋”
        游戏能显示游戏的历史，并且可以 “跳回” 到之前的步骤。这个功能不是这个游戏才有的 -- 拥有 “撤销” 和 “重做”
        功能是目前应用的一个很通用的需求。避免直接对数据进行突变式的修改使得我们能够保存先前版本游戏记录的完整历史，并在之后重新使用。


        #### 追踪改变


        追踪改变对于突变的对象来说是很困难的因为它们直接被修改了。我们需要遍历整个对象树，然后比较突变对象和它之前的拷贝来追踪这种变化。


        追踪改变对于不变的对象来说是相当简单的。如果这个不变的对象的引用和之前的不一样了，那么它就改变了。


        #### 判断什么时候该在 React 中重新渲染


        不变形的主要优点是它帮助你在 Reac 构建纯组件。不变的数据能很容易判断是否发生了变化，我们以此来决定一个组件是否需要重新渲染。


        你能 `shouldComponentUpdate()`
        学到更多关于不变性的知识，以及通过阅读[性能优化](https://zh-hans.reactjs.org/docs/optimizing-performance.html#examples)来学习如何构建纯组件。


        ### 什么是函数式组件


        我们将马上将 Square 改成一个函数式组件。


        在 React 中，函数式组件是一种编写组件的简单写法，你只需要包含 `render` 方法里面的内容，并且不需要 `state`
        。我们通过编写函数，接收 `props` 作为输入，然后返回需要渲染的内容来定义组件，而不是之前通过定义继承自
        `React.Component` 的类来定义组件。函数式组件没有类组件那么冗长，并且大多数的组件都能通过这样的方式来定义。


        用下面的这个函数来取代 Square 类：


        ```JavaScript

        function Square(props) {
          return (
            <button className="square" onClick={props.onClick}>
              {props.value}
            </button>
          );
        }

        ```


        我们已经将两处 `this.props` 出现的位置改成了 `props`。
  - name: 开始翻转
    commit: f423342
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 当保存上面的改变之后，你的 Board 组件看起来应该是这样的：
          post: >+
            [查看此时的所有项目代码](https://github.com/pftom/react101/tree/f423342ec01b616665f25b5734ef36e1bf7a4157)

    explain:
      pre: >+
        现在我们需要修复之前的缺陷 -- 在之前我们的 “井字棋” 游戏中，“O“ 出现不了。


        我们将把第一步移动默认设置为 “X”。我们可以在 Board 的 `constructor` 里面修改它：


        ```JavaScript

        class Board extends React.Component {
          constructor(props) {
            super(props);
            this.state = {
              squares: Array(9).fill(null),
              xIsNext: true,
            };
          }
        ```


        每当一个选手移动一步，`xIsNext`  （一个布尔值）将会翻转来判断下一个选手将会出现什么，并且翻转后的状态会被保存在 `state`
        里面。我们将修改 Board 的 `handleClick` 函数来翻转 `xIsNext` 的值：


        ```JavaScript
          handleClick(i) {
            const squares = this.state.squares.slice();
            squares[i] = this.state.xIsNext ? 'X' : 'O';
            this.setState({
              squares: squares,
              xIsNext: !this.state.xIsNext,
            });
          }
        ```

  - name: 显示获胜者
    commit: e999aee
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 保存上面所做的修改，目前你的 `src/index.js` 的内容应该看起来是这样子的：
          post: >-
            [查看此时所有项目代码](https://github.com/pftom/react101/tree/e999aeecb3fff63ae8c3037ed422b1a377cb90bc)
    explain:
      post: 恭喜你！你现在已经有一个可以运行的 “井字棋” 游戏了。并且你还学习了 React 的基础知识。所以你可能是这里面真正的赢家！
  - name: 再次状态提升
    commit: eaccb8e
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 当保存上面的修改之后，现在我们的 `src/index.js` 应该是这样的：
          post: >-
            [查看此时所有项目代码](https://github.com/pftom/react101/tree/eaccb8e7a87389e541b684a30cf5e201b2439c2b)
    explain:
      pre: >-
        作为最后的练习，让我们使得游戏 “回到过去” 变得可能。


        ### 保存移动的历史


        如果我们突变式的修改了 `squares` 数组，实现时间旅行就会变得很困难。


        然而，我们在每步移动都使用了 `slice()` 来创建 `squares`
        数组的一份新的拷贝，将其看做是[不可变的](#使用函数式组件)。这使得我们可以保存 `squares`
        数组的每一步历史版本，然后在在已经发生的移动历史之间跳转。


        我们将把 `squares` 数组的历史版本保存到另外一个 `history` 数组中。`history`
        代表了从游戏开始到上一步移动所有棋盘格的状态。它看起来是下面这样的：


        ```JavaScript

        history = [
          // Before first move
          {
            squares: [
              null, null, null,
              null, null, null,
              null, null, null,
            ]
          },
          // After first move
          {
            squares: [
              null, null, null,
              null, 'X', null,
              null, null, null,
            ]
          },
          // After second move
          {
            squares: [
              null, null, null,
              null, 'X', null,
              null, null, 'O',
            ]
          },
          // ...
        ]

        ```


        现在我们需要思考，那个组件应该保存 `history` 状态。


        我们想让顶层的 Game 组件来展示历史移动列表。这需要获取 `history` 才能做到，所以我们把 `history` 移动到顶层的
        Game 组件的 `state` 中来。


        将 `history` 状态移动到 Game 组件中之后，我们需要将 `squares` state 从它的子组件 Board
        中删除。就像我们之前将 Square 组件中的[状态提升](#状态提升)到 Board 组件中一样，我们现在将状态从 Board
        组件提升到顶层的 Game 组件中。这使得 Game 组件完全控制了 Board 的数据，并且使得它可以操纵 Board
        组件来渲染之前的移动状态。


        首先，我们将在 Game 的 constructor 中来设置它的初始状态：


        ```JavaScript

        class Game extends React.Component {
          constructor(props) {
            super(props);
            this.state = {
              history: [{
                squares: Array(9).fill(null),
              }],
              xIsNext: true,
            };
          }

          render() {
            return (
              <div className="game">
                <div className="game-board">
                  <Board />
                </div>
                <div className="game-info">
                  <div>{/* status */}</div>
                  <ol>{/* TODO */}</ol>
                </div>
              </div>
            );
          }
        }

        ```


        接下来，我们将修改 Board 组件，使得它接收来自 Game 组件的 `squares` 和 `onClick` props。因为目前我们在
        Board 组件上定义了唯一的一个点击处理函数来处理众多的 Square 的点击事件，所以为了指示那个 Square 被点击了，我们需要通过它的
        `onClick` 事件处理函数传递它所在的位置。下面是迁移 Board 组件所必须的步骤：


        - 删除 Board 里面的 `constructor` 。

        - 在 Board 的 `renderSquare` 里面将 `this.state.squares[i]` 替换层
        `this.props.squares[i]` 。

        - 在 Board 的 `renderSquare` 里面将 `this.handleClick(i)` 替换成
        `this.props.handleClick(i)`。


        Board 组件现在看起来是这样的：


        ```JavaScript

        class Board extends React.Component {
          handleClick(i) {
            const squares = this.state.squares.slice();
            if (calculateWinner(squares) || squares[i]) {
              return;
            }
            squares[i] = this.state.xIsNext ? 'X' : 'O';
            this.setState({
              squares: squares,
              xIsNext: !this.state.xIsNext,
            });
          }

          renderSquare(i) {
            return (
              <Square
                value={this.props.squares[i]}
                onClick={() => this.props.onClick(i)}
              />
            );
          }

          render() {
            const winner = calculateWinner(this.state.squares);
            let status;
            if (winner) {
              status = 'Winner: ' + winner;
            } else {
              status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
            }

            return (
              <div>
                <div className="status">{status}</div>
                <div className="board-row">
                  {this.renderSquare(0)}
                  {this.renderSquare(1)}
                  {this.renderSquare(2)}
                </div>
                <div className="board-row">
                  {this.renderSquare(3)}
                  {this.renderSquare(4)}
                  {this.renderSquare(5)}
                </div>
                <div className="board-row">
                  {this.renderSquare(6)}
                  {this.renderSquare(7)}
                  {this.renderSquare(8)}
                </div>
              </div>
            );
          }
        }

        ```


        我们将更新 Game 组件的 `render` 函数来使用最新历史记录，并通过这一历史记录来展示游戏的状态：


        ```JavaScript


        ```


        因为 Game 组件目前已经渲染了游戏的状态，我们可以删除 Board 组件的 `render` 方法里面对于的代码了。当我们重构完，Board
        的 `render` 方法看起来像这样：


        ```diff

        render() {
           const history = this.state.history;
           const current = history[history.length - 1];
           const winner = calculateWinner(current.squares);

           let status;
           if (winner) {
             status = 'Winner: ' + winner;
           } else {
             status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
           }

            return (
              <div className="game">
                <div className="game-board">
                 <Board
                   squares={current.squares}
                   onClick={(i) => this.handleClick(i)}
                 />
               </div>
               <div className="game-info">
                 <div>{status}</div>
                  <ol>{/* TODO */}</ol>
                </div>
              </div>
            );
          }
        ```


        最终，我们需要把 Board 里面的 `handleClick` 方法移动到 Game 组件中。我们还需要对 `handleClick`
        做出一点修改，因为 Game 组件的 `state` 结构不一样。在 Game 的 `handleClick`
        方法中，我们将新的历史记录条目添加到 `history` 中。


        ```JavaScript
          handleClick(i) {
            const history = this.state.history;
            const current = history[history.length - 1];
            const squares = current.squares.slice();
            if (calculateWinner(squares) || squares[i]) {
              return;
            }
            squares[i] = this.state.xIsNext ? 'X' : 'O';
            this.setState({
              history: history.concat([{
                squares: squares,
              }]),
              xIsNext: !this.state.xIsNext,
            });
          }
        ```


        > **注意**

        > 不像你熟悉的 `push()` 方法，`concat()` 方法不会突变式的修改原数组，所以我们更青睐它。


        现在，Board 组件只需要 `renderSquare` 和 `render` 方法了。游戏的状态和 `handleClick` 方法都定义在
        Game 组件中。
  - name: 展示移动历史
    commit: b61a7ff
    diff:
      - file: src/index.js
        display: true
        explain:
          post: >+
            [查看此时全部项目代码](https://github.com/pftom/react101/tree/b61a7ff4be8309405687f619a043490864065d89)

    explain:
      pre: >-
        因为我们记录了井字棋游戏的历史，我们现在可以将这份历史列表展示给玩家。


        我们之前学到，React 元素是 JavaScript 对象；我们可以在应用中传递它们。为了渲染多个元素，我们可以一个 React 元素数组。


        在 JavaScript 中，数组有一个 [map()
        方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)，普遍的用于将一份数据映射到另外一份数据，例如：


        ```JavaScript

        const numbers = [1, 2, 3];

        const doubled = numbers.map(x => x * 2); // [2, 4, 6]

        ```


        使用 `map` 方法，我们可以将移动的历史映射成展示在屏幕上的 React button 元素。


        让我们在 Game 的 `render` 方法里来 `map` 我们的 `history`：
      post: >-
        对于井字棋游戏历史里的每一步移动，我们都创建了一个包含 `<button>` 的列表元素包含 `<li>` 。Button 有一个
        `onClick` 处理函数来调用 `this.jumpTo()`。我们目前还没有实现 `jumpTo()`
        方法。现在我们应该可以看到游戏板旁边出现了一列移动记录，并且在我们的开发者工具控制台里面会显示下面的警告：


        > **Warning: Each child in an array or iterator should have a unique
        “key” prop. Check the render method of “Game”.**


        让我们来讨论一下上面的警告的含义。
  - name: 加上 key
    commit: 859840a
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: >-
            在井字棋游戏历史记录中，每个过去的移动步骤都有一个唯一的 ID
            与之关联：那就是这个移动步骤的顺序数字。因为这些移动步骤不会重排列，被删除或者在中间新插入步骤，所以使用移动步骤列表的所有是安全的。


            在 Game 组件的 `render` 方法中。我们给 `<li>` 元素加上 `key` ，然后 React 的关于 `key`
            的警告应该就消失了：
          post: >-
            [查看此时所有项目代码](https://github.com/pftom/react101/tree/859840a10ed3f7db69d131f3f3d81f14a924621d)
    explain:
      pre: >-
        当我们渲染一个列表时，React 会保存一些关于渲染列表元素的信息。当我们更新列表时，React
        需要判断哪些元素改变了。我们可能添加、删除、重排列或者更新了列表元素。


        想象一下下面的改变，从：


        ```JavaScript

        <li>Alexa: 7 tasks left</li>

        <li>Ben: 5 tasks left</li>

        ```

        到：


        ```JavaScript

        <li>Ben: 9 tasks left</li>

        <li>Claudia: 8 tasks left</li>

        <li>Alexa: 5 tasks left</li>

        ```


        除了更新计数，一个人来看上面的改变可能会说：“我们交换了 Alexa 和 Ben 的顺序，然后再 Alexa 和 Ben 中间插入了
        Claudia。然而，React 是一个计算机程序，它无法理解我们的意思。因为 React 不知道我们的目的，所以我们需要给每个元素列表指定一个
        ***key*** 属性来区分它的邻近元素。一种选项是使用字符串
        `alexa`，`ben`，`claudia`。如果我们展示来自数据库的数据，Alexa，Ben 和 Claudia 的数据库 ID 可以作为
        key 使用：


        ```JavaScript

        <li key={user.id}>{user.name}: {user.taskCount} tasks left</li>

        ```


        当一个列表重新渲染的时候，React 通过查看每个元素的 key ，并且搜索先前列表查看是否有对应的匹配元素。如果目前的列表存在一个之前没有的
        key，React 会创建一个组件。如果当前列表相比先前列表丢失了一个 key，React 会销毁之前的组件。如果两个 key
        相匹配，React 会把之前的组件直接挪过来用。Keys 告诉 React 每个组件的身份，这使得 React
        可以在重新渲染时维护状态。如果组件的 key 变了，那么这个组件会被销毁，然后使用新的 state 来重新创建这个组件。


        `key` 在 React 中是一个特殊的保留属性（就像 `ref` 一样 -- 一个更加高级的特性）。当一个元素被创建后，React
        会提取出它的  `key` 属性，然后将这个 `key` 直接保存在返回的元素里面。即使 `key` 看上去属于 `props` ，`key`
        不能够使用 `this.props.key` 来引用。React 自动的使用 `key` 来决定组件是否更新。我们无法获取组件的 `key`
        值。


        **无论你何时构建一个动态列表组件，我们都强烈推荐你给列表元素赋予 `key` 属性。** 如果你的数据没有合适的 `key`
        ，你可以要考虑重构你是数据来确保它有。


        如果没有指定 `key` ，React 将在控制台打印一条警告，然后默认使用数组的索引作为 `key` 。使用数据的所有作为 `key`
        有时候会产生问题，比如当你尝试对列表重排序或者插入或删除列表元素时。显式的传递 `key={i}`
        会使得警告被去掉，但是和默认使用索引一样会产生问题，并且在绝大多数情况下是不被推荐的。


        `key` 不需要全局唯一；它们只需要在组件和它们的兄弟节点间唯一。
  - name: 实现时间旅行
    commit: 4493d81
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: 保存上面的修改，你的代码将是这个样子：
          post: >-
            [查看此时全部项目代码](https://github.com/pftom/react101/tree/4493d81d35c04e9dbc7075703b4146aee647db82)
    explain:
      pre: >-
        当你点击任何一个列表元素按钮会触发错误，因为 `jumpTo` 方法还没有定义。在我们实现 `jumpTo` 方法之前，我们将给 Game
        组件的 `state` 加上 `stepNumber` 来标志目前我们所看到的步骤。


        首先，在 Game 的 `constructor` 的初始 `state` 里面加上 `stepNumber: 0` ：


        ```diff

        class Game extends React.Component {
          constructor(props) {
            super(props);
            this.state = {
              history: [{
                squares: Array(9).fill(null),
              }],
              stepNumber: 0,
              xIsNext: true,
            };
          }
        ```


        接着，我们将在 Game 里面定义 `jumpTo` 方法来更新 `stepNumber` 。并且当 `stepNumber`
        是偶数时，我们将把 `xIsNext` 设置为 true。


        ```JavaScript
          handleClick(i) {
            // this method has not changed
          }

          jumpTo(step) {
            this.setState({
              stepNumber: step,
              xIsNext: (step % 2) === 0,
            });
          }

          render() {
            // this method has not changed
          }
        ```


        我们将对 Game 的 `handleClick` 做一点修改 -- 就是那个当你点击 Square 会触发调用的方法。


        我们现在加入了 `stepNumber` state 来表示当前展示给用户的步骤。当我们进行了一步新的移动时，我们需要在
        `this.setState` 语句中加入 `stepNumber: history.length` 来更新 `stepNumber`
        。这确保在移动了新的一步的时候不会错误的显示相同的移动步骤。


        我们还需要将之前读取 `this.state.history` 更新成读取 `this.state.history.slice(0,
        this.state.stepNumber + 1)`。这确保我们 ”回到过去“ 时，再从这个点进行新的移动，我们需要丢掉过去从这个点开始的
        “未来” 的历史记录，因为它们现在已经变得不在正确了。


        ```JavaScript
          handleClick(i) {
            const history = this.state.history.slice(0, this.state.stepNumber + 1);
            const current = history[history.length - 1];
            const squares = current.squares.slice();
            if (calculateWinner(squares) || squares[i]) {
              return;
            }
            squares[i] = this.state.xIsNext ? 'X' : 'O';
            this.setState({
              history: history.concat([{
                squares: squares
              }]),
              stepNumber: history.length,
              xIsNext: !this.state.xIsNext,
            });
          }
        ```


        最终，我们将修改 Game 组件的 `render` 方法，从之前总是渲染最后一个步骤变成根据 `stepNumber` 渲染目前选中的步骤。


        ```JavaScript
          render() {
            const history = this.state.history;
            const current = history[this.state.stepNumber];
            const winner = calculateWinner(current.squares);

            // the rest has not changed
        ```


        如果我们点击游戏历史记录的任一步骤，这个井字棋游戏板就会立即更新，去展示当时这个步骤的样子。
      post: |-
        ### 总结一下

        恭喜你！你已经创建了一个井字棋游戏：

        - 可以让你看井字棋游戏，
        - 在选手获得胜利时会给予显示，
        - 将游戏的历史记录保存为游戏进度，
        - 允许玩家回顾游戏的历史记录以及跳转到之前的游戏步骤。

        做的好！我们期望你现在已经对 React 有一个很深刻的理解了。

        点击这个链接查看最终的结果：[最终结果。](https://codepen.io/huan1043269994/pen/JjjaBBw)
